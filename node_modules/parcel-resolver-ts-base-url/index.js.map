{"mappings":"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","sources":["src/index.js","src/utils/get-ts-config.js","src/utils/memo.js","src/utils/parse-jsonc.js","src/steps/match-path.js","src/steps/parse-paths.js","src/steps/resolve-base.js","src/utils/match-file.js","src/constants.js","src/utils/get-package.js","src/steps/resolve-path.js"],"sourcesContent":["import path from \"path\";\n\nimport { Resolver } from \"@parcel/plugin\";\n\nimport { getTsConfig } from \"./utils/get-ts-config\";\n\nimport { matchPath } from \"./steps/match-path\";\nimport { parsePaths } from \"./steps/parse-paths\";\nimport { resolveBase } from \"./steps/resolve-base\";\nimport { resolvePath } from \"./steps/resolve-path\";\n\nimport { POSSIBLE_EXTENSION_REGEX } from \"./constants\";\n\nexport default new Resolver({\n    async resolve({ specifier, dependency, options }) {\n        const isJavascriptImport = POSSIBLE_EXTENSION_REGEX.test(\n            dependency.resolveFrom || \"\"\n        );\n\n        if (!isJavascriptImport) {\n            return null;\n        }\n\n        try {\n            const { tsConfig, path: sourcePath } = await getTsConfig(\n                options.inputFS,\n                dependency.resolveFrom\n                    ? path.dirname(dependency.resolveFrom)\n                    : options.projectRoot,\n                options.projectRoot\n            );\n\n            const rawBaseUrl = tsConfig.compilerOptions?.baseUrl;\n            const rawPaths = tsConfig.compilerOptions?.paths;\n\n            if (!rawBaseUrl && !rawPaths) {\n                return null;\n            }\n\n            const baseUrl = path.resolve(sourcePath, rawBaseUrl || \".\");\n            const paths = parsePaths(rawPaths);\n\n            const matchedPath = matchPath(specifier, paths);\n\n            if (matchedPath !== null) {\n                const resolved = await resolvePath(\n                    options.inputFS,\n                    specifier,\n                    matchedPath,\n                    baseUrl\n                );\n\n                if (!resolved) {\n                    return null;\n                }\n\n                return {\n                    filePath: resolved,\n                    invalidateOnFileChange: [resolved],\n                };\n            }\n\n            const resolvedFromBase = await resolveBase(\n                options.inputFS,\n                specifier,\n                baseUrl\n            );\n\n            if (resolvedFromBase !== null) {\n                return {\n                    filePath: resolvedFromBase,\n                    invalidateOnFileChange: [resolvedFromBase],\n                };\n            }\n        } catch (err) {\n            return {\n                diagnostics: [\n                    {\n                        message:\n                            err instanceof Error\n                                ? err.message\n                                : \"Unknown error\",\n                        hints: [\n                            \"Check if a tsconfig.json file exists and has valid configuration in it\",\n                        ],\n                    },\n                ],\n            };\n        }\n\n        return null;\n    },\n});\n","import path from \"path\";\n\nimport { createMemo } from \"./memo\";\nimport { parseJsoncOrThrow } from \"./parse-jsonc\"\n\n/**\n * @param {import('./memo').Memo<Record<string, unknown>>} memo\n * @param {import('@parcel/fs').FileSystem} fs\n * @param {string} sourcePath\n * @param {string} projectRoot\n * @returns {Promise<{ tsConfig: Record<string, any>, path: string }>}\n */\nconst getTsConfig = async (memo, fs, sourcePath, projectRoot) => {\n    while (true) {\n        if (memo[sourcePath]) {\n            return { tsConfig: memo[sourcePath], path: sourcePath };\n        }\n\n        const tsConfigPath = path.join(sourcePath, \"tsconfig.json\");\n\n        try {\n            if (await fs.exists(tsConfigPath)) {\n                const tsConfigContent = await fs.readFile(\n                    tsConfigPath,\n                    \"utf-8\"\n                );\n\n                const parsedConfig = parseJsoncOrThrow(tsConfigContent);\n\n                return {\n                    tsConfig: (memo[sourcePath] = parsedConfig),\n                    path: sourcePath,\n                };\n            }\n        } catch (err) {\n            const errMsg = err instanceof Error ? err.message : err;\n            throw new Error(\n                `Unexpected exception when reading ${tsConfigPath}: ${errMsg}`\n            );\n        }\n\n        if (sourcePath === projectRoot) {\n            throw new Error(\n                `tsconfig.json not found in ${path.relative(\n                    projectRoot,\n                    sourcePath\n                )}`\n            );\n        }\n\n        sourcePath = path.join(sourcePath, \"..\");\n    }\n};\n\nconst memoizedGetTsConfig = createMemo(getTsConfig);\n\nexport { memoizedGetTsConfig as getTsConfig };\n","/**\n * @template T\n * @typedef {Record<string, T>} Memo\n */\n\n/**\n * @template {Array<unknown>} A\n * @template T, R\n * @param {(memo: Memo<T>, ...args: A) => R} func\n * @returns {(...args:A) => R}\n */\nconst createMemo = (func) => {\n    /**\n     * @type {Memo<T>}\n     */\n    const memo = {};\n\n    return (...args) => {\n        return func(memo, ...args);\n    };\n};\n\nexport { createMemo };\n","import * as JSONC from \"jsonc-parser\";\n\n/**\n * @param {string} jsoncString\n * @returns {any}\n */\nexport function parseJsoncOrThrow(jsoncString){\n    /**\n     * @type {JSONC.ParseError[]}\n    */\n    const errors = [];\n    const parsingResult = JSONC.parse(\n        jsoncString,\n        errors,\n        {allowTrailingComma: true}\n    );\n    if(errors.length > 0){\n        const {error: errorCode, offset} = errors[0];\n        const errName = JSONC.printParseErrorCode(errorCode);\n        throw new Error(\n            `Cannot parse JSONC: got ${errName} at position ${offset}`\n        );\n    }\n    return parsingResult\n}\n","/**\n * @param {string} specifier\n * @param {import(\"./parse-paths\").Path[]} paths\n * @returns {import(\"./parse-paths\").Path | null}\n */\nconst matchPath = (specifier, paths) => {\n    for (const path of paths) {\n        if (path.regexp.test(specifier)) {\n            return path;\n        }\n    }\n\n    return null;\n};\n\nexport { matchPath };\n","/**\n * @typedef {{match: string, resolve: string[] | string, regexp: RegExp}} Path\n * @param {Record<string, string[] | string>} paths\n * @returns {Path[]}\n */\nconst parsePaths = (paths) => {\n    if (!paths) {\n        return [];\n    }\n\n    return Object.keys(paths).map((path) => {\n        return {\n            match: path,\n            resolve: paths[path],\n            regexp: new RegExp(`^${path.replace(\"*\", \".*\")}$`),\n        };\n    });\n};\n\nexport { parsePaths };\n","import path from \"path\";\n\nimport { matchFile } from \"../utils/match-file\";\n\n/**\n * @param {import('@parcel/fs').FileSystem} fs\n * @param {string} specifier\n * @param {string} baseUrl\n * @returns {Promise<string | null>}\n */\nconst resolveBase = async (fs, specifier, baseUrl) => {\n    const filePath = path.resolve(baseUrl, specifier);\n\n    return await matchFile(fs, filePath);\n};\n\nexport { resolveBase };\n","import path from \"path\";\n\nimport { POSSIBLE_EXTENSIONS } from \"../constants\";\n\nimport { getPackage } from \"./get-package\";\n\n/**\n * @param {import('@parcel/fs').FileSystem} fs\n * @param {string} matchedPath\n * @param {string[]} extensions\n * @returns {Promise<string | null>}\n */\nconst matchFile = async (fs, matchedPath, extensions = POSSIBLE_EXTENSIONS) => {\n    const exists = await fs.exists(matchedPath);\n\n    const stat = exists && (await fs.stat(matchedPath));\n    const isDirectory = stat && stat.isDirectory();\n\n    if (exists) {\n        if (!isDirectory) {\n            return matchedPath;\n        }\n\n        const pkg = await getPackage(fs, matchedPath);\n\n        const main = pkg && (pkg.main || pkg.module);\n        if (typeof main === \"string\") {\n            return path.resolve(matchedPath, main);\n        }\n    }\n\n    const filePath = isDirectory\n        ? path.resolve(matchedPath, \"index\")\n        : matchedPath;\n\n    for (const extension of extensions) {\n        const completePath = `${filePath}.${extension}`;\n\n        if (await fs.exists(completePath)) {\n            return completePath;\n        }\n    }\n\n    return null;\n};\n\nexport { matchFile };\n","const POSSIBLE_EXTENSIONS = [\"js\", \"jsx\", \"ts\", \"tsx\", \"cjs\", \"mjs\"];\n\nconst POSSIBLE_EXTENSION_REGEX = /[.](([cm]js)|([jt]sx?))$/;\n\nexport { POSSIBLE_EXTENSIONS, POSSIBLE_EXTENSION_REGEX };\n","import path from \"path\";\n\nimport { createMemo } from \"./memo\";\n\n/**\n * @param {import('./memo').Memo<Record<string, unknown>>} memo\n * @param {import('@parcel/fs').FileSystem} fs\n * @param {string} folder\n * @returns {Promise<Record<string, unknown> | null>}\n */\nconst getPackage = async (memo, fs, folder) => {\n    if (memo[folder]) {\n        return memo[folder];\n    }\n\n    const packagePath = path.resolve(folder, \"package.json\");\n\n    const packageExists = await fs.exists(packagePath);\n\n    if (!packageExists) {\n        return null;\n    }\n\n    const packageContent = await fs.readFile(packagePath);\n\n    try {\n        // @ts-expect-error packageContent is a string\n        return (memo[folder] = JSON.parse(packageContent));\n    } catch (_) {\n        return null;\n    }\n};\n\nconst memoizedGetPackage = createMemo(getPackage);\n\nexport { memoizedGetPackage as getPackage };\n","import path from \"path\";\n\nimport { matchFile } from \"../utils/match-file\";\n\n/**\n * @param {import('@parcel/fs').FileSystem} fs\n * @param {string} specifier\n * @param {import('./parse-paths').Path} matchedPath\n * @param {string} baseUrl\n * @returns {Promise<string | null>}\n */\nconst resolvePath = async (fs, specifier, matchedPath, baseUrl) => {\n    const strippedMatch = matchedPath.match.replace(\"*\", \"\");\n\n    const wildcard = specifier.replace(strippedMatch, \"\");\n\n    const resolves =\n        typeof matchedPath.resolve === \"string\"\n            ? [matchedPath.resolve]\n            : matchedPath.resolve;\n\n    for (const resolve of resolves) {\n        const filePath = path.resolve(baseUrl, resolve.replace(\"*\", wildcard));\n\n        const matchedFile = await matchFile(fs, filePath);\n\n        if (matchedFile) {\n            return matchedFile;\n        }\n    }\n\n    return null;\n};\n\nexport { resolvePath };\n"],"names":[],"version":3,"file":"index.js.map","sourceRoot":"/"}