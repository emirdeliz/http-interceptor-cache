var $2SVpt$path = require("path");
var $2SVpt$parcelplugin = require("@parcel/plugin");
var $2SVpt$jsoncparser = require("jsonc-parser");

function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}
function $parcel$defineInteropFlag(a) {
  Object.defineProperty(a, '__esModule', {value: true, configurable: true});
}
function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}

$parcel$defineInteropFlag(module.exports);

$parcel$export(module.exports, "default", () => $f2cb25104f54a54a$export$2e2bcd8739ae039);



/**
 * @template T
 * @typedef {Record<string, T>} Memo
 */ /**
 * @template {Array<unknown>} A
 * @template T, R
 * @param {(memo: Memo<T>, ...args: A) => R} func
 * @returns {(...args:A) => R}
 */ const $5e14d100fb609d6a$export$c0c6c8b9c16bf6aa = (func)=>{
    /**
     * @type {Memo<T>}
     */ const memo = {
    };
    return (...args)=>{
        return func(memo, ...args);
    };
};



function $09b5d6b6d939a915$export$8c2e76aa961c60fb(jsoncString) {
    /**
     * @type {JSONC.ParseError[]}
    */ const errors = [];
    const parsingResult = $2SVpt$jsoncparser.parse(jsoncString, errors, {
        allowTrailingComma: true
    });
    if (errors.length > 0) {
        const { error: errorCode , offset: offset  } = errors[0];
        const errName = $2SVpt$jsoncparser.printParseErrorCode(errorCode);
        throw new Error(`Cannot parse JSONC: got ${errName} at position ${offset}`);
    }
    return parsingResult;
}


/**
 * @param {import('./memo').Memo<Record<string, unknown>>} memo
 * @param {import('@parcel/fs').FileSystem} fs
 * @param {string} sourcePath
 * @param {string} projectRoot
 * @returns {Promise<{ tsConfig: Record<string, any>, path: string }>}
 */ const $a57ec68efc2d301e$var$getTsConfig = async (memo, fs, sourcePath, projectRoot)=>{
    while(true){
        if (memo[sourcePath]) return {
            tsConfig: memo[sourcePath],
            path: sourcePath
        };
        const tsConfigPath = ($parcel$interopDefault($2SVpt$path)).join(sourcePath, "tsconfig.json");
        try {
            if (await fs.exists(tsConfigPath)) {
                const tsConfigContent = await fs.readFile(tsConfigPath, "utf-8");
                const parsedConfig = $09b5d6b6d939a915$export$8c2e76aa961c60fb(tsConfigContent);
                return {
                    tsConfig: memo[sourcePath] = parsedConfig,
                    path: sourcePath
                };
            }
        } catch (err) {
            const errMsg = err instanceof Error ? err.message : err;
            throw new Error(`Unexpected exception when reading ${tsConfigPath}: ${errMsg}`);
        }
        if (sourcePath === projectRoot) throw new Error(`tsconfig.json not found in ${($parcel$interopDefault($2SVpt$path)).relative(projectRoot, sourcePath)}`);
        sourcePath = ($parcel$interopDefault($2SVpt$path)).join(sourcePath, "..");
    }
};
const $a57ec68efc2d301e$export$9244408f0e45143 = $5e14d100fb609d6a$export$c0c6c8b9c16bf6aa($a57ec68efc2d301e$var$getTsConfig);


/**
 * @param {string} specifier
 * @param {import("./parse-paths").Path[]} paths
 * @returns {import("./parse-paths").Path | null}
 */ const $dbc4813ae54e9876$export$81336c211d5ff295 = (specifier, paths)=>{
    for (const path of paths){
        if (path.regexp.test(specifier)) return path;
    }
    return null;
};


/**
 * @typedef {{match: string, resolve: string[] | string, regexp: RegExp}} Path
 * @param {Record<string, string[] | string>} paths
 * @returns {Path[]}
 */ const $709abe9669f7e7f1$export$c3bde059a94bfd4d = (paths)=>{
    if (!paths) return [];
    return Object.keys(paths).map((path)=>{
        return {
            match: path,
            resolve: paths[path],
            regexp: new RegExp(`^${path.replace("*", ".*")}$`)
        };
    });
};




const $0e012721181e3aea$export$4cd241f91f0c9591 = [
    "js",
    "jsx",
    "ts",
    "tsx",
    "cjs",
    "mjs"
];
const $0e012721181e3aea$export$92403c259ab1b2d6 = /[.](([cm]js)|([jt]sx?))$/;




/**
 * @param {import('./memo').Memo<Record<string, unknown>>} memo
 * @param {import('@parcel/fs').FileSystem} fs
 * @param {string} folder
 * @returns {Promise<Record<string, unknown> | null>}
 */ const $6962dcd2c15cdfcf$var$getPackage = async (memo, fs, folder)=>{
    if (memo[folder]) return memo[folder];
    const packagePath = ($parcel$interopDefault($2SVpt$path)).resolve(folder, "package.json");
    const packageExists = await fs.exists(packagePath);
    if (!packageExists) return null;
    const packageContent = await fs.readFile(packagePath);
    try {
        // @ts-expect-error packageContent is a string
        return memo[folder] = JSON.parse(packageContent);
    } catch (_) {
        return null;
    }
};
const $6962dcd2c15cdfcf$export$3972a8b667a037fb = $5e14d100fb609d6a$export$c0c6c8b9c16bf6aa($6962dcd2c15cdfcf$var$getPackage);


/**
 * @param {import('@parcel/fs').FileSystem} fs
 * @param {string} matchedPath
 * @param {string[]} extensions
 * @returns {Promise<string | null>}
 */ const $6d997804c843fae0$export$8c5f08ee9028738a = async (fs, matchedPath, extensions = $0e012721181e3aea$export$4cd241f91f0c9591)=>{
    const exists = await fs.exists(matchedPath);
    const stat = exists && await fs.stat(matchedPath);
    const isDirectory = stat && stat.isDirectory();
    if (exists) {
        if (!isDirectory) return matchedPath;
        const pkg = await $6962dcd2c15cdfcf$export$3972a8b667a037fb(fs, matchedPath);
        const main = pkg && (pkg.main || pkg.module);
        if (typeof main === "string") return ($parcel$interopDefault($2SVpt$path)).resolve(matchedPath, main);
    }
    const filePath = isDirectory ? ($parcel$interopDefault($2SVpt$path)).resolve(matchedPath, "index") : matchedPath;
    for (const extension of extensions){
        const completePath = `${filePath}.${extension}`;
        if (await fs.exists(completePath)) return completePath;
    }
    return null;
};


/**
 * @param {import('@parcel/fs').FileSystem} fs
 * @param {string} specifier
 * @param {string} baseUrl
 * @returns {Promise<string | null>}
 */ const $4e117d1a8875534a$export$1843678c0218f957 = async (fs, specifier, baseUrl)=>{
    const filePath = ($parcel$interopDefault($2SVpt$path)).resolve(baseUrl, specifier);
    return await $6d997804c843fae0$export$8c5f08ee9028738a(fs, filePath);
};




/**
 * @param {import('@parcel/fs').FileSystem} fs
 * @param {string} specifier
 * @param {import('./parse-paths').Path} matchedPath
 * @param {string} baseUrl
 * @returns {Promise<string | null>}
 */ const $c14ce8c5e528d221$export$b09f2ff0bbcb43c7 = async (fs, specifier, matchedPath, baseUrl)=>{
    const strippedMatch = matchedPath.match.replace("*", "");
    const wildcard = specifier.replace(strippedMatch, "");
    const resolves = typeof matchedPath.resolve === "string" ? [
        matchedPath.resolve
    ] : matchedPath.resolve;
    for (const resolve of resolves){
        const filePath = ($parcel$interopDefault($2SVpt$path)).resolve(baseUrl, resolve.replace("*", wildcard));
        const matchedFile = await $6d997804c843fae0$export$8c5f08ee9028738a(fs, filePath);
        if (matchedFile) return matchedFile;
    }
    return null;
};



var $f2cb25104f54a54a$export$2e2bcd8739ae039 = new $2SVpt$parcelplugin.Resolver({
    async resolve ({ specifier: specifier , dependency: dependency , options: options  }) {
        const isJavascriptImport = $0e012721181e3aea$export$92403c259ab1b2d6.test(dependency.resolveFrom || "");
        if (!isJavascriptImport) return null;
        try {
            var ref, ref1;
            const { tsConfig: tsConfig , path: sourcePath  } = await $a57ec68efc2d301e$export$9244408f0e45143(options.inputFS, dependency.resolveFrom ? ($parcel$interopDefault($2SVpt$path)).dirname(dependency.resolveFrom) : options.projectRoot, options.projectRoot);
            const rawBaseUrl = (ref = tsConfig.compilerOptions) === null || ref === void 0 ? void 0 : ref.baseUrl;
            const rawPaths = (ref1 = tsConfig.compilerOptions) === null || ref1 === void 0 ? void 0 : ref1.paths;
            if (!rawBaseUrl && !rawPaths) return null;
            const baseUrl = ($parcel$interopDefault($2SVpt$path)).resolve(sourcePath, rawBaseUrl || ".");
            const paths = $709abe9669f7e7f1$export$c3bde059a94bfd4d(rawPaths);
            const matchedPath = $dbc4813ae54e9876$export$81336c211d5ff295(specifier, paths);
            if (matchedPath !== null) {
                const resolved = await $c14ce8c5e528d221$export$b09f2ff0bbcb43c7(options.inputFS, specifier, matchedPath, baseUrl);
                if (!resolved) return null;
                return {
                    filePath: resolved,
                    invalidateOnFileChange: [
                        resolved
                    ]
                };
            }
            const resolvedFromBase = await $4e117d1a8875534a$export$1843678c0218f957(options.inputFS, specifier, baseUrl);
            if (resolvedFromBase !== null) return {
                filePath: resolvedFromBase,
                invalidateOnFileChange: [
                    resolvedFromBase
                ]
            };
        } catch (err) {
            return {
                diagnostics: [
                    {
                        message: err instanceof Error ? err.message : "Unknown error",
                        hints: [
                            "Check if a tsconfig.json file exists and has valid configuration in it", 
                        ]
                    }, 
                ]
            };
        }
        return null;
    }
});


//# sourceMappingURL=index.js.map
